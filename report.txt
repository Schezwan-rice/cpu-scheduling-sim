# CPU SCHEDULING ALGORITHMS VISUALIZER PROJECT REPORT

## 1. Project Overview

The CPU Scheduling Algorithms Visualizer is an interactive web application designed to help students and educators understand CPU scheduling algorithms through dynamic visualizations. This tool bridges the gap between theoretical knowledge and practical understanding of operating systems concepts.

Operating Systems courses often present CPU scheduling algorithms as abstract concepts, making them difficult to grasp. This project addresses this challenge by providing a visual interface where users can:
- Observe algorithm behavior with different process sets
- Compare multiple algorithms side-by-side
- Analyze key metrics like waiting time, turnaround time, and CPU utilization

The application implements four fundamental CPU scheduling algorithms:
1. First-Come, First-Served (FCFS)
2. Shortest Job First (SJF)
3. Round Robin (RR)
4. Priority Scheduling

Built with Next.js, TypeScript, and Tailwind CSS, the application provides a responsive and accessible user interface with visualizations implemented using Framer Motion and Chart.js.

## 2. Module-Wise Breakdown

The project follows a modular architecture based on Next.js's app router structure:

### 2.1 Core Application Structure
- **app/**: Main application directory containing pages and routes
  - **layout.tsx**: Global layout structure
  - **page.tsx**: Homepage with navigation to algorithm-specific pages
  - **globals.css**: Global styles

### 2.2 Algorithm-Specific Modules
- **app/fcfs/**: First-Come, First-Served visualization
- **app/sjf/**: Shortest Job First visualization
- **app/round-robin/**: Round Robin visualization with time quantum controls
- **app/priority/**: Priority Scheduling visualization
- **app/comparison/**: Side-by-side algorithm comparison tool

### 2.3 Reusable Components
- **components/**: UI component directory
  - **algorithm-animation.tsx**: Core visualization component
  - **comparison-chart.tsx**: Comparative metrics visualization
  - **ui/**: Atomic UI components from Shadcn/UI

### 2.4 Utility Layer
- **lib/**: Utility functions, algorithm implementations, and shared logic
- **hooks/**: Custom React hooks for state management and animations

This structure promotes code reusability and separation of concerns, allowing for easy extension to include additional algorithms.

## 3. Functionalities

The CPU Scheduling Algorithms Visualizer offers key features to enhance learning of operating systems concepts:

### 3.1 Algorithm Visualizations
- **FCFS**: Displays process execution in arrival order with non-preemptive execution
- **SJF**: Visualizes shortest-burst-time-first selection with optimal waiting time demonstration
- **Round Robin**: Shows time-quantum-based scheduling with configurable quantum values
- **Priority Scheduling**: Demonstrates priority-based execution with optional aging mechanism

### 3.2 Analysis Tools
- **Comparative Analysis**: Side-by-side algorithm comparison with identical process sets
- **Performance Metrics**: Calculation and visualization of waiting time, turnaround time, and CPU utilization
- **Chart Visualizations**: Bar and line charts showing relative algorithm performance

### 3.3 Interactive Features
- **Process Creation**: Custom process set creation with adjustable parameters
- **Animation Controls**: Speed adjustment, pause/resume, and step-by-step execution
- **Educational Content**: Contextual explanations of algorithm principles and behaviors
- **Responsive Design**: Interface adaptation for different screen sizes with accessibility features

## 4. Technology Used

The project leverages modern web technologies to deliver an interactive educational application:

### 4.1 Programming Languages
- **TypeScript/JavaScript**: Core programming with static typing
- **HTML5/CSS3**: Markup and styling

### 4.2 Frontend Framework and Libraries
- **Next.js (15.1.0)**: React framework for routing and rendering
- **React (19.x)**: UI component library
- **Tailwind CSS**: Utility-first styling framework
- **Framer Motion**: Animation library for visualizations
- **Chart.js**: Data visualization library
- **Shadcn/UI**: Component library built on Radix UI

### 4.3 Development Tools
- **Node.js**: JavaScript runtime environment
- **npm/pnpm**: Package management
- **Git/GitHub**: Version control and collaboration

### 4.4 Architecture Patterns
- **Component-Based Architecture**: Reusable UI components
- **Server and Client Components**: Next.js hybrid rendering
- **Responsive Design**: Multi-device support
- **Type-Safe Development**: Enhanced code quality through TypeScript

## 5. Flow Diagram

Below is a flow diagram representing the application architecture and user interaction paths:

```mermaid
graph TD
    %% User Entry Point
    User[User] --> HomePage[Home Page]
    
    %% Main Navigation Flow
    HomePage --> AlgorithmSelection[Algorithm Selection]
    HomePage --> ComparisonTool[Comparison Tool]
    
    %% Algorithm Selection Branches
    AlgorithmSelection --> FCFS[FCFS Algorithm]
    AlgorithmSelection --> SJF[SJF Algorithm]
    AlgorithmSelection --> RR[Round Robin Algorithm]
    AlgorithmSelection --> Priority[Priority Algorithm]
    
    %% Algorithm Pages Common Flow
    subgraph AlgorithmPage[Algorithm Page Flow]
        InputForm[Process Input Form] --> Validation[Input Validation]
        Validation --> Simulation[Algorithm Simulation]
        Simulation --> Visualization[Animation Visualization]
        Visualization --> Metrics[Performance Metrics]
    end
    
    %% Connect Each Algorithm to Common Flow
    FCFS --> AlgorithmPage
    SJF --> AlgorithmPage
    RR --> AlgorithmPage
    Priority --> AlgorithmPage
    
    %% Comparison Tool Flow
    ComparisonTool --> CompInputForm[Comparison Input Form]
    CompInputForm --> SimulateAll[Simulate All Algorithms]
    SimulateAll --> CompareResults[Compare Results]
    
    %% System Components
    subgraph SystemComponents[System Components]
        UIComponents[UI Components] <--> SchedulingLogic[Scheduling Logic]
        SchedulingLogic <--> AnimationEngine[Animation Engine]
    end
```

The diagram illustrates the user journey through the application, showing how users navigate from the homepage to specific algorithm pages or the comparison tool. It also depicts the common workflow within algorithm pages and key system component interactions.

## 6. Revision Tracking on GitHub

The project uses GitHub for version control and collaboration:

### 6.1 Repository Information
- **Repository**: cpu-scheduling-sim (https://github.com/Schezwan-rice/cpu-scheduling-sim)
- **Main Branch**: main

### 6.2 Development Workflow
- **Feature-based branching** with format `feature/feature-name`
- **Semantic commit messages** following conventional commits standard
- **Pull request process** with code reviews and automated checks
- **Issue tracking** using templates and labels for categorization
- **CI/CD pipeline** for testing, code quality checks, and deployment
- **Semantic versioning** (MAJOR.MINOR.PATCH) for releases

This structured approach ensures a clean, organized codebase with clear history, facilitating collaboration and future contributions.

## 7. Conclusion and Future Scope

### 7.1 Conclusion
The CPU Scheduling Algorithms Visualizer successfully creates an interactive educational tool that bridges the gap between theoretical concepts and practical understanding of CPU scheduling algorithms. Key achievements include:

- Development of visual simulations for four fundamental scheduling algorithms
- Implementation of comparative analysis tools for algorithm evaluation
- Creation of an accessible, responsive interface using modern web technologies
- Delivery of an educational resource for operating systems students and educators

The project demonstrates how interactive visualization can enhance understanding of complex computer science concepts, making it a valuable addition to educational technology resources.

### 7.2 Future Scope
Potential areas for enhancement include:

- **Additional Algorithms**: SRTF, Multilevel Queue, and Multilevel Feedback Queue implementations
- **Enhanced Visualizations**: Timeline scrubbing, process state transitions, and 3D representations
- **Advanced Features**: Custom algorithm creation, performance prediction, and workload pattern generation
- **Educational Enhancements**: Interactive tutorials, quizzes, and gamification elements
- **Technical Improvements**: Offline functionality, mobile app versions, and performance optimization
- **Collaboration Features**: User accounts, result sharing, and community examples

These enhancements would further expand the educational value and technical capabilities of the application, creating a more comprehensive learning resource for operating systems concepts.

## 8. References

### 8.1 Academic References
1. Silberschatz, A., Galvin, P. B., & Gagne, G. (2018). *Operating System Concepts* (10th ed.). Wiley.
2. Tanenbaum, A. S., & Bos, H. (2014). *Modern Operating Systems* (4th ed.). Pearson.
3. Stallings, W. (2017). *Operating Systems: Internals and Design Principles* (9th ed.). Pearson.

### 8.2 Technical Documentation
1. Next.js Documentation: https://nextjs.org/docs
2. React Documentation: https://reactjs.org/docs
3. Framer Motion Documentation: https://www.framer.com/motion
4. Chart.js Documentation: https://www.chartjs.org/docs

### 8.3 Online Resources
1. GeeksforGeeks - CPU Scheduling: https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/
2. Operating Systems: Three Easy Pieces: https://pages.cs.wisc.edu/~remzi/OSTEP/
3. VisuAlgo - Algorithm Visualization: https://visualgo.net/
4. CPU Scheduling Simulator: https://boonsuen.com/process-scheduling-solver

## Appendix

### A. Problem Statement

The traditional approach to teaching CPU scheduling algorithms in operating systems courses presents several challenges:

1. **Abstract Concepts**: CPU scheduling algorithms involve abstract concepts that are difficult to visualize mentally.
2. **Limited Interactivity**: Static textbooks and lectures don't allow students to experiment with algorithm behavior.
3. **Difficulty Comparing Algorithms**: Students struggle to compare different algorithms without seeing them side-by-side.
4. **Complex Metrics**: Performance metrics like waiting time and turnaround time are challenging to calculate manually.

This project aims to address these challenges by creating an interactive visualization tool that:
- Provides accurate implementation of FCFS, SJF, Round Robin, and Priority Scheduling algorithms
- Offers dynamic, animated visualizations of process execution
- Enables customization of process parameters for experimentation
- Calculates and displays performance metrics automatically
- Allows side-by-side algorithm comparison
- Presents educational content that connects visualizations to theory

The target outcome is enhanced student comprehension through visual learning, practical experience with algorithm behavior, and development of comparative analysis skills.

### B. Core Implementation Excerpt

The core algorithm visualization component implements the scheduling algorithms and their animations:

```typescript
// Excerpt from components/algorithm-animation.tsx

// Algorithm simulation functions
const simulateFCFS = (procs: Process[]): number[] => {
  const sortedByArrival = [...procs].sort((a, b) => a.arrivalTime - b.arrivalTime)
  const result: number[] = []
  let currentTime = 0
  
  for (const proc of sortedByArrival) {
    // If there's a gap between current time and process arrival, add idle time
    if (proc.arrivalTime > currentTime) {
      for (let i = 0; i < proc.arrivalTime - currentTime; i++) {
        result.push(0) // 0 indicates CPU is idle
      }
      currentTime = proc.arrivalTime
    }
    
    // Add process execution time
    for (let i = 0; i < proc.burstTime; i++) {
      result.push(proc.id)
    }
    currentTime += proc.burstTime
  }
  
  return result
}

const simulateSJF = (procs: Process[]): number[] => {
  const result: number[] = []
  let remainingProcs = [...procs]
  let currentTime = 0
  
  while (remainingProcs.length > 0) {
    // Find available processes (arrived by current time)
    const availableProcs = remainingProcs.filter(p => p.arrivalTime <= currentTime)
    
    if (availableProcs.length === 0) {
      // No process available, advance time to next arrival
      const nextArrival = Math.min(...remainingProcs.map(p => p.arrivalTime))
      for (let i = 0; i < nextArrival - currentTime; i++) {
        result.push(0) // CPU idle
      }
      currentTime = nextArrival
      continue
    }
    
    // Find shortest job among available processes
    const shortestProc = availableProcs.reduce(
      (min, p) => p.burstTime < min.burstTime ? p : min,
      availableProcs[0]
    )
    
    // Execute the shortest job
    for (let i = 0; i < shortestProc.burstTime; i++) {
      result.push(shortestProc.id)
    }
    currentTime += shortestProc.burstTime
    
    // Remove completed process
    remainingProcs = remainingProcs.filter(p => p.id !== shortestProc.id)
  }
  
  return result
}

// Additional algorithms and helper functions omitted for brevity
```

This implementation demonstrates how the scheduling algorithms are translated into code, providing accurate simulations that power the visualizations. The component uses React hooks for state management and Framer Motion for animations, creating an effective educational tool. 